# import random
import datetime
import time

import pandas as pd

from robot.api.deco import keyword, not_keyword, library
from robot.libraries.BuiltIn import BuiltIn

from item_builder_engine import ItemBuilderEngine

@library(scope='GLOBAL', version='0.0.2')
class SynData:
    """ 
    Test data is required in many projects. In some cases, the test data is 
    generated once and anchored in the test scripts. In other projects, 
    random test data is used so that each subsequent test run can increase 
    the test coverage in terms of variance.

    The following basic considerations led to the development of this 
    library:

    - _The library should manage data that has already been generated:_
      In some cases, a test date is required multiple times in a test case. 
      To do this, the test date can be stored in a variable and accessed 
      when needed. Another idea is for the library to remember what has been 
      generated and take over the management itself.
    - _Data should be consistent where possible:_
      There may be dependencies among the data generated by different 
      keywords. The keywords ``Get Name`` and ``Get First Name`` are a 
      simple example of consistent data. ``Get Name`` returns a string 
      consisting of a first name and a last name. From the perspective of 
      test data consistency, the first name in the return values of the 
      keywords is expected to be identical.
    - _Data should be as close to reality as possible:_
      For example, if an address is to be used in a test case, in Germany it 
      consists of a postal code and a city. This library is required to 
      ensure that the combination of postal code and city matches. This 
      requirement can only be guaranteed for localizations that have a 
      specialized generator.
    - _Test cases should be as easy as possible to repeat with data from a 
      previous test run:_
      If a test case fails during an automated test run, a tester wants to 
      be able to analyze the test case with the data that was used in the 
      test run. For this purpose, logging of the test data was provided, 
      and when the library is imported with a log file, the data is 
      simply "played back".

    == Use of context ==

    A context can be understood as a data space. In this data space, the library 
    remembers the data that is randomly generated and, when new data is to be 
    generated, ensures that the data is consistent.
    
    An example of the use of a context is a role or persona that is required in 
    the test case. In an online shop, this could be a customer, for example. 
    In the test case, a context with the name ``customer`` can be created, and 
    thus, for example, the first name is only randomly generated the first time 
    using ``Get First Name``. Each subsequent call to ``Get First Name`` returns 
    the first name that was generated the first time, as long as the context is 
    not left.
    
    Multiple contexts can also be created and automatically generated with 
    ``Set Context`` if the context does not exist. If a context is set that is 
    known to the library, it is reactivated. This allows you to switch between 
    contexts in the test case with ``Set Context``.

    == Log test data and replay it ==

    *This feature is not yet implemented in the library.*
    
    The goal is to log the keywords called and their return values during test 
    execution. The log file is created in the Robot Framework output directory.

    The path to one of these log files can be passed when importing the library. 
    If this happens, the library does not generate test data for the test cases 
    contained in the log file, but instead returns the values from the log file.
    """
    ROBOT_AUTO_KEYWORDS = False

    MODE_DEF = 0
    MODE_REP = 1

    INSTANCE = None

    def __init__(self, localization: str ="en_US", logging: bool =False, logfile: str =None, replayfile: str =None):
        """
        The constructor is used to initialize the library.

        | =Arguments=      | =Descripion= |
        | ``localization`` | The parameter can be used to specify the localization to be used if no context is set. The default value is ``en_US``. |
        | ``logging``      | This parameter can be used to enable the recording of test data. The default value is ``False``, which means that recording is disabled. |
        | ``logfile``      | During initialization, the caller can specify the name of the file for recording the test data. The specification is only evaluated if ``logging`` has the value ``True``. The default value is ``None``. In this case, the name is generated automatically. The format contains the date and time when the test was started. A concrete example might look like this: ``SynData-20260204-124643.log`` |
        | ``replayfile``   | The parameter can be used to pass the full path to a log file so that the file is set as the data source for the keywords. If a file name is transferred here, many functions of the library, such as context management, are overridden. The default value is ``None``, which means that the generators are used to generate data. |
        """
        if(None == replayfile):
            self.mode = SynData.MODE_DEF
            self.replayfile = None
        else:
            self.mode = SynData.MODE_REP
            self.replayfile = replayfile
        self.context = None
        self.data = {}
        self.default_localization = localization
        self.ibe = ItemBuilderEngine()
        self.logging = (True == logging)
        if (self.logging):
            path = BuiltIn().get_variable_value("${OUTPUT DIR}")
            if (None == logfile):
                file_name = datetime.datetime.now().strftime("SynData-%Y%m%d-%H%M%S")
                self.logfile = f"{path}/{file_name}.csv"
            else:
                if (-1 == logfile.find(".")):
                    self.logfile = f"{path}/{logfile}.csv"
                else:
                    self.logfile = f"{path}/{logfile}"
            self.logdata = pd.DataFrame(None, columns=["timestamp", "item", "value", "test_suite", "test_case", "keyword"])
        SynData.INSTANCE = self

    def get_keyword_names(self):
        # Get all attributes and their values from the library.
        attributes = [(name, getattr(self, name)) for name in dir(self)]
        # Filter out attributes that do not have 'robot_name' set.
        keywords = [(name, value) for name, value in attributes
                    if hasattr(value, 'robot_name')]
        # Return value of 'robot_name', if given, or the original 'name'.
        return [value.robot_name or name for name, value in keywords]

    @staticmethod
    @keyword(tags=["Context"])
    def Set_Context(context: str, localization: str ='en_US', focus: str ='test') -> str:
        """
        The keyword can be used to set a context.

        The context is a data space in which the test data is generated 
        consistently and the generated test data is stored.

        If there is no suitable context, the initial data structure for the 
        context is created and the context is set.

        A focus can be set for a context that describes the scope of validity of 
        the context. The following values are defined for the parameter 
        ``focus``:

        - ``global``: In this case, the context is available in all test suites 
          during test execution. This can be useful if there is a test date 
          that should be the same for all test cases.
        - ``suite``: In this case, the context is limited to one test suite. This 
          means that the data is available to all test cases that belong to the 
          test suite in which the context was created.
        - ``test``: In this case, the context is limited to the test case in which 
          it was created.

        | =Arguments=      | =Descripion= |
        | ``context``      | The name of the context is a string that describes the data space from a technical perspective. This parameter must contain a value. |
        | ``localization`` | The parameter can be used to specify the localization for this context. The default value is ``en_US``. |
        | ``focus``        | The parameter can be used to define the scope of the context. The valid values for this parameter are ``global``, ``suite``, and ``test``. The default value is ``test``, which means that the context is limited to the test case in which it is set. |
        """
        print(context)
        print(localization)
        match focus.lower():
            case "global":
                context_id=f"global.{context}"
            case "suite":
                context_id=f"{SynData.INSTANCE._get_current_test_suite()}.{context}"
            case "test":
                context_id=f"{SynData.INSTANCE._get_current_test_suite()}.{SynData.INSTANCE._get_current_test_case()}.{context}"
            case _:
                context_id=f"global.{context}"
                focus = "global"
        if (not (context_id in SynData.INSTANCE.data.keys())):
            SynData.INSTANCE.data[context_id] = {}
            SynData.INSTANCE.data[context_id].update({"meta":{"localization" : localization, "name" : context, "focus" : focus.lower()}})
        SynData.INSTANCE.context = context_id
    
    @staticmethod
    @keyword(tags=["Context"])
    def Release_Context():
        """
        This keyword removes the context.

        After calling this keyword, it is ensured that the keywords that 
        generate test cases do not access already stored data. Data consistency 
        is also not guaranteed if no context is set.
        """
        SynData.INSTANCE.context = None

    @staticmethod
    @keyword(tags=["Context"])
    def Get_Context() -> str:
        """
        The keyword returns the name of the context, if a context is set.
        
        If no context is set, the value ``None`` is returned.
        """
        if(None == SynData.INSTANCE.context):
            # In this case, no context is set and therefore None is returned.
            return None
        # return self.context
        if (None != SynData.INSTANCE.context):
            context_name = SynData.INSTANCE.data.get(SynData.INSTANCE.context).get("meta").get("name")
            context_focus = SynData.INSTANCE.data.get(SynData.INSTANCE.context).get("meta").get("focus")
            if(       (f"{SynData.INSTANCE._get_current_test_suite()}.{SynData.INSTANCE._get_current_test_case()}.{context_name}" == SynData.INSTANCE.context)
                  and ("test" == context_focus)):
                # In this case, a context was detected that exactly matches the test case currently being executed.
                return context_name
            elif(     (f"{SynData.INSTANCE._get_current_test_suite()}.{context_name}" == SynData.INSTANCE.context)
                  and ("suite" == context_focus)):
                # In this case, a context was detected that exactly matches the test suite currently being executed.
                return context_name
            elif(     (f"global.{context_name}" == SynData.INSTANCE.context)
                  and ("global" == context_focus)):
                # In this case, a context with a global focus was detected.
                return context_name
            else:
                # In this case, a context is set, but the context has a focus 
                # that does not match either the test case or the test suite.
                # Consequently, the value None is returned.
                return None
        else: 
            # In this case, no context is set and therefore None is returned.
            return None
    
    @staticmethod
    @keyword(tags=["Person"])
    def Get_Name(sex="*") -> str:
        """
        The keyword provides a name consisting of a first name and a last name.
        
        | =Arguments= | =Descripion= |
        | ``sex``     | This parameter can be used to specify the gender, which affects the first name. The permitted values are ``m`` for male, ``f`` for female, ``d`` for diverse, and ``*`` for no gender specified. |
        """
        if ( None == SynData.Get_Context() ):
            localization = SynData.INSTANCE.default_localization
        else:
            localization = SynData.INSTANCE.data.get(SynData.INSTANCE.context).get("meta").get("localization")
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, localization, "Get Name", "person.name", {"sex":sex})

    @staticmethod    
    @keyword(tags=["Person"])
    def Get_First_Name(sex="*") -> str:
        """
        The keyword provides a first name.
        
        | =Arguments= | =Descripion= |
        | ``sex``     | This parameter can be used to specify the gender, which affects the first name. The permitted values are ``m`` for male, ``f`` for female, ``d`` for diverse, and ``*`` for no gender specified. |
        """
        if ( None == SynData.Get_Context() ):
            localization = SynData.INSTANCE.default_localization
        else:
            localization = SynData.INSTANCE.data.get(SynData.INSTANCE.context).get("meta").get("localization")
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, localization, "Get First Name", "person.first_name", {"sex":sex})
    
    @staticmethod
    @keyword(tags=["Person"])
    def Get_Last_Name() -> str:
        """
        The keyword provides a last name.
        """
        if ( None == SynData.Get_Context() ):
            localization = SynData.INSTANCE.default_localization
        else:
            localization = SynData.INSTANCE.data.get(SynData.INSTANCE.context).get("meta").get("localization")
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, localization, "Get Last Name", "person.last_name", {})

    @not_keyword
    def get_mode(self) -> int:
        return self.mode
    
    @not_keyword
    def get_item(self, item) -> str:
        if ( None == self.context ):
            return None
        else: 
            return self.data[self.context].get(item)

    @not_keyword
    def add_item(self, item, value):
        if( None != self.context ):
            self.data[self.context].update({item: value})

    @not_keyword
    def add_log_entry(self, keyword, item, value):
        if ((self.logging) and (None != self.logfile)):
            ts = datetime.datetime.now().strftime("%Y-%m-%d %X") + ("-" if time.timezone > 0 else "+") + time.strftime("%H:%M", time.gmtime(abs(time.timezone)))
            suite = BuiltIn().get_variable_value("${SUITE NAME}")
            test_case = BuiltIn().get_variable_value("${TEST NAME}")
            self.logdata.loc[len(self.logdata)] = [ts, item, value, suite, test_case, keyword]
            print(self.logdata)
            self.logdata.to_csv(self.logfile, index_label="index")
            #file = open(self.logfile, "a")
            #file.write(f"{ts},{suite},{test_case},{keyword},{item},{value}\n")
            #file.close()

    @not_keyword
    def _get_current_test_suite(self) -> str:
        return BuiltIn().get_variable_value("${SUITE NAME}")

    @not_keyword
    def _get_current_test_case(self) -> str:    
        return BuiltIn().get_variable_value("${TEST NAME}")
    
    def get_replay_file(self) -> str:
        return self.replayfile

    # @not_keyword
    # def Hello_World(self):
    #     """ Bei diesem Schl체sselwort ist der Name verd채chtig. ;-) Es ist das erste Schl체sselwort und
    #         kann nicht einmal "Hallo" sagen."""
    #     pass

    # @not_keyword
    # def Create_Person(self, gender="any", forenames=1, forename_hyphen=False, compound_name=False, birth_name=False):
    #     """Lorem ipsum dolor it."""
    #     person_data = {}
    #     person_data.update({"meta":{"type":"physical person", "mode":"synthetic", "category":"person"}})
    #     if (self.is_male(gender)):
    #         person_data.update({"forename" : self.get_random_male_forename(forenames, forename_hyphen)})
    #         person_data.update({"gender": "male"})
    #     elif (self.is_female(gender)):
    #         person_data.update({"forename" : self.get_random_female_forename(forenames, forename_hyphen)})
    #         person_data.update({"gender": "female"})
    #     elif (self.is_third_gender(gender)):
    #         if(0 == random.randrange(1, 1000) % 2):
    #             person_data.update({"forename": self.get_random_male_forename(forenames, forename_hyphen)})
    #         else:
    #             person_data.update({"forename": self.get_random_female_forename(forenames, forename_hyphen)})
    #         person_data.update({"gender" : "third sex"})
    #     else:
    #         if(0 == random.randrange(1, 1000) % 2):
    #             person_data.update({"forename": self.get_random_male_forename(forenames, forename_hyphen)})
    #             person_data.update({"gender": "male"})
    #         else:
    #             person_data.update({"forename": self.get_random_female_forename(forenames, forename_hyphen)})
    #             person_data.update({"gender": "female"})
    #     person_data.update({"surname" : self.get_random_surname(compound_name)})
    #     if (birth_name):
    #         if (compound_name) :
    #             person_data.update({"birthname": person_data.get("surname").split("-",1)[0]})
    #         else:
    #             person_data.update({"birthname": self.get_random_surname(False)})
    #     return person_data

    # @not_keyword
    # def Add_Address(self, person_data, country="de", postcode_min="01000", postcode_max="99999", housenumber=0, housenumber_max=99 ):
    #     """Lorem ipsum dolor it."""
    #     if self.de_locations == None:
    #         self.de_locations = utils.support_de.MailingAddressGermany()
    #     person_data = self.de_locations.add_location(person_data)
    #     return person_data

    # @not_keyword
    # def Add_Address_By_Filter(self, person_data, filter, address_attribute="address"):
    #     """Lorem ipsum dolor it."""
    #     if self.de_locations == None:
    #         self.de_locations = utils.support_de.MailingAddressGermany()
    #     retval=person_data
    #     country=str(filter.get("country", {}).get("value", "de")).lower()
    #     if (country in ["de", "germany", "deutschland"]):
    #         retval=self.de_locations.add_filtered_location(person_data, filter, address_attribute)
    #     return retval

    # @not_keyword
    # def Get_Filtered_Locations(self, filter={}):
    #     """Lorem ipsum dolor it."""
    #     if self.de_locations == None:
    #         self.de_locations = utils.support_de.MailingAddressGermany()
    #     return self.de_locations.get_locations_filtered_by_postcode(self.de_locations.cities, filter)

    # @not_keyword
    # def Add_Cellphone_Number(self, item, filter={}, information_path="communication.cellphone"):
    #     """Lorem ipsum dolor it."""
    #     if self.de_communication == None:
    #         self.de_communication = utils.support_de.TelecommunicationGermany()
    #     return self.de_communication.add_cellphone_number(item, filter, information_path)


    # @not_keyword
    # def Add_Landline_Number(self, item, filter={}, information_path="communication.landline"):
    #     """Lorem ipsum dolor it."""
    #     if self.de_communication == None:
    #         self.de_communication = utils.support_de.TelecommunicationGermany()
    #     return self.de_communication.add_landline_number(item, filter, information_path)

    # @not_keyword
    # def is_male(self, gender):
    #     """Lorem ipsum dolor it."""
    #     return gender.lower() in ["m", "mr", "male", "m채nnlich"]

    # @not_keyword
    # def is_female(self, gender):
    #     """Lorem ipsum dolor it."""
    #     return gender.lower() in ["w", "mrs", "f", "female", "weiblich"]

    # @not_keyword
    # def is_third_gender(self, gender):
    #     """Lorem ipsum dolor it."""
    #     return gender.lower() in ["d", "mx", "third sex", "third gender", "divers"]

    # @not_keyword
    # def get_random_male_forename(self, forenames, hyphen):
    #     """Lorem ipsum dolor it."""
    #     retval = self.forenames_male[random.randrange(0,len(self.forenames_male))]
    #     for i in range(1, forenames):
    #         if (hyphen):
    #             if (i > retval.count("-")):
    #                 retval = retval + "-" + self.forenames_male[random.randrange(0,len(self.forenames_male))]
    #         else:
    #             retval = retval + " " + self.forenames_male[random.randrange(0, len(self.forenames_male))]
    #     return retval

    # @not_keyword
    # def get_random_female_forename(self, forenames, hyphen):
    #     """Lorem ipsum dolor it."""
    #     retval = self.forenames_female[random.randrange(0,len(self.forenames_female))]
    #     for i in range(1, forenames):
    #         if (hyphen):
    #             if (i > retval.count("-")):
    #                 item = self.forenames_female[random.randrange(0,len(self.forenames_female))]
    #                 while 0 != item.count("-"):
    #                     item = self.forenames_female[random.randrange(0,len(self.forenames_female))]
    #                 retval = retval + "-" + item
    #         else:
    #             retval = retval + " " + self.forenames_female[random.randrange(0,len(self.forenames_female))]
    #     return retval

    # @not_keyword
    # def get_random_surname(self, compound_name):
    #     """Lorem ipsum dolor it."""
    #     retval = self.surnames[random.randrange(0,len(self.surnames))]
    #     if (compound_name):
    #         retval = retval + "-" + self.surnames[random.randrange(0,len(self.surnames))]
    #     return retval

    # #de_locations = utils.support_de.MailingAddressGermany()
    # #de_communication = utils.support_de.TelecommunicationGermany()

    # de_locations = None
    # de_communication = None

